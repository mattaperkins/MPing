#!/usr/bin/env python3

# mping-multi — Python curses multi-host ping with Unicode bar graphs
#
# This version includes:
#   • jitter display (mping-style)
#   • CSV parallel logging (--csv-out filename)
#   • corrected blocks/dots behaviour
#   • version header in display only
#   • © Matt Perkins notice in display only
#
# NO OTHER CHANGES HAVE BEEN MADE.

import argparse
import curses
import locale
import platform
import queue
import re
import signal
import subprocess
import sys
import threading
import time
from typing import Dict, List, Optional, Tuple

locale.setlocale(locale.LC_ALL, "")

# ---------------- Config defaults ----------------
DEFAULT_INTERVAL_MS = 1000
DEFAULT_TIMEOUT_S   = 1
DEFAULT_WINDOW      = 60
DEFAULT_BAR_WIDTH   = 24
DEFAULT_SLOW_MS     = 150

DEFAULT_MAX_LAT_MS  = 120
DEFAULT_BLOCKS_MODE = "avg"
DEFAULT_BLOCKS_AVG  = 5
DEFAULT_STYLE       = "blocks"

IS_MAC = (platform.system() == "Darwin")

PING_RTT_RE = re.compile(r'time[=<]\s*([\d.,]+)\s*ms', re.IGNORECASE)
PING_SUMMARY_RE = re.compile(
    r'(?:rtt|round-trip)\s+[^\=]*=\s*([\d.,]+)/([\d.,]+)/([\d.,]+)/',
    re.IGNORECASE
)

# ---------------- UIConfig (must come BEFORE parse_args) -------------------
class UIConfig:
    def __init__(self):
        self.interval_ms = DEFAULT_INTERVAL_MS
        self.timeout_s   = DEFAULT_TIMEOUT_S
        self.bar_width   = DEFAULT_BAR_WIDTH
        self.window      = DEFAULT_WINDOW
        self.style       = DEFAULT_STYLE
        self.slow_ms     = DEFAULT_SLOW_MS
        self.max_lat_ms  = DEFAULT_MAX_LAT_MS
        self.blocks_mode = DEFAULT_BLOCKS_MODE
        self.blocks_avg  = DEFAULT_BLOCKS_AVG
        self.force_cols  = None


# ---------------- Data classes -------------------
class HostStats:
    __slots__ = (
        "host","sent","recv",
        "rtt_sum","rtt_cnt","rtt_min","rtt_max",
        "last_rtt_ms","prev_rtt_ms","jitter_ms",
        "win_size","win_pos","win_ok",
        "last_error","dot_len",
        "rtt_ring","rtt_ring_cap"
    )

    def __init__(self, host: str, window: int, ring_cap: int):
        self.host = host
        self.sent = 0
        self.recv = 0

        self.rtt_sum = 0.0
        self.rtt_cnt = 0
        self.rtt_min = 0.0
        self.rtt_max = 0.0

        self.last_rtt_ms: Optional[float] = None
        self.prev_rtt_ms: Optional[float] = None
        self.jitter_ms: float = 0.0

        self.win_size = window
        self.win_pos = 0
        self.win_ok = [0] * window

        self.last_error = None
        self.dot_len = 0

        self.rtt_ring = []
        self.rtt_ring_cap = max(1, ring_cap)

    def update_jitter(self, new_rtt: Optional[float]):
        if new_rtt is not None:
            if self.last_rtt_ms is not None:
                self.jitter_ms = abs(new_rtt - self.last_rtt_ms)
            self.prev_rtt_ms = self.last_rtt_ms

    def push_window(self, ok: int):
        self.win_ok[self.win_pos] = 1 if ok else 0
        self.win_pos = (self.win_pos + 1) % self.win_size

    def push_rtt(self, rtt_ms: Optional[float]):
        if rtt_ms is None:
            return
        self.rtt_ring.append(float(rtt_ms))
        if len(self.rtt_ring) > self.rtt_ring_cap:
            del self.rtt_ring[0]

    def ring_avg(self) -> Optional[float]:
        if not self.rtt_ring:
            return None
        return sum(self.rtt_ring) / len(self.rtt_ring)

    def loss_pct(self) -> float:
        return (100.0 * (self.sent - self.recv) / self.sent) if self.sent else 0.0

    def avg_rtt(self) -> float:
        return self.rtt_sum / self.rtt_cnt if self.rtt_cnt else 0.0


# ---------------- RTT parsing --------------------
def _parse_rtt(stdout: str, stderr: str) -> Tuple[Optional[float], Optional[float]]:
    last_ms = None
    avg_ms  = None

    def to_float(s):
        try:
            return float(s.replace(",", "."))
        except:
            return None

    for line in stdout.splitlines():
        m = PING_RTT_RE.search(line)
        if m:
            v = to_float(m.group(1))
            if v is not None:
                last_ms = v

    combined = stdout + "\n" + (stderr or "")
    sm = PING_SUMMARY_RE.search(combined)
    if sm:
        avg_ms = to_float(sm.group(2))

    return last_ms, avg_ms


# ---------------- Worker thread ------------------
class PingWorker(threading.Thread):
    def __init__(self, host: str, interval_ms: int, timeout_s: int,
                 outq: "queue.Queue[Tuple[str,dict]]"):
        super().__init__(daemon=True)
        self.host = host
        self.interval_ms = interval_ms
        self.timeout_s = timeout_s
        self.q = outq
        self.stop_evt = threading.Event()

        if IS_MAC:
            ms = max(1, int(self.timeout_s * 1000))
            self.base_cmd = ["ping", "-n", "-c", "1", "-W", str(ms), self.host]
        else:
            self.base_cmd = ["ping", "-n", "-c", "1", "-W", str(self.timeout_s), self.host]

    def stop(self):
        self.stop_evt.set()

    def run(self):
        while not self.stop_evt.is_set():
            t0 = time.time()
            sent = 1
            recv = 0
            last_ms = None
            avg_ms = None
            err = None

            try:
                proc = subprocess.run(self.base_cmd, text=True, capture_output=True)
                if proc.returncode == 0:
                    recv = 1

                last_ms, avg_ms = _parse_rtt(proc.stdout or "", proc.stderr or "")

                if proc.returncode != 0:
                    tail = (proc.stderr or proc.stdout).strip().splitlines()
                    err = tail[-1] if tail else None
            except Exception as e:
                err = str(e)

            self.q.put((self.host, {
                "timestamp": time.time(),
                "sent": sent,
                "recv": recv,
                "last_ms": last_ms,
                "avg_ms": avg_ms,
                "err": err,
            }))

            elapsed_ms = int((time.time() - t0) * 1000)
            self.stop_evt.wait(max(0, self.interval_ms - elapsed_ms) / 1000.0)


# ---------------- CSV Logger ---------------------
class CSVLogger:
    def __init__(self, filename: str):
        self.f = open(filename, "a")
        self.f.write("timestamp,host,sent,recv,loss_pct,jitter,last_rtt,avg_rtt,min,max\n")
        self.f.flush()

    def write(self, record: str):
        self.f.write(record + "\n")
        self.f.flush()

    def close(self):
        self.f.close()


# ---------------- UI Helper functions ---------------------
def colour_for_mping_style(loss_pct: float, avg_ms: float, slow_ms: int) -> int:
    if loss_pct > 0:
        return 1
    if avg_ms >= slow_ms:
        return 3
    return 2

def draw_bar_blocks_latency(ms, width, max_lat):
    if width <= 0 or ms is None or ms <= 0:
        filled = 0
    else:
        frac = min(1.0, ms / max_lat)
        filled = int(frac * width + 0.5)
        if filled == 0:
            filled = 1
    filled = max(0, min(width, filled))
    return "█" * filled + "░" * (width - filled)

def draw_bar_dots_progress(dot_len, width):
    dot_len = max(0, min(width, dot_len))
    return "•" * dot_len + "·" * (width - dot_len)

def fit(s, n):
    return s if len(s) <= n else s[:n - 1] + "…"


# ---------------- Main Curses Loop ------------------
def curses_main(stdscr, hosts, cfg, csv_logger):
    curses.curs_set(0)
    stdscr.nodelay(True)

    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_CYAN, -1)

    stats = {h: HostStats(h, cfg.window, cfg.blocks_avg) for h in hosts}
    q = queue.Queue()
    workers = [PingWorker(h, cfg.interval_ms, cfg.timeout_s, q) for h in hosts]
    for w in workers:
        w.start()

    MIN_HOST = 8
    MAX_HOST = 24
    MIN_BAR = 10

    # Jitt column included here
    NUMERIC_WIDTH = (
        1 +
        7 + 1 +
        7 + 1 +
        7 + 1 +
        7 + 1 +
        7 + 1 +
        7 + 2
    )

    try:
        while True:

            while True:
                try:
                    host, update = q.get_nowait()
                except queue.Empty:
                    break

                hs = stats[host]

                hs.sent += update["sent"]
                hs.recv += update["recv"]

                new_rtt = update["last_ms"]
                hs.update_jitter(new_rtt)

                if new_rtt is not None:
                    hs.last_rtt_ms = new_rtt
                    hs.rtt_sum += new_rtt
                    hs.rtt_cnt += 1
                    hs.rtt_min = new_rtt if hs.rtt_cnt == 1 else min(hs.rtt_min, new_rtt)
                    hs.rtt_max = new_rtt if hs.rtt_cnt == 1 else max(hs.rtt_max, new_rtt)
                    hs.push_rtt(new_rtt)

                elif update["avg_ms"] is not None:
                    avg = update["avg_ms"]
                    hs.last_rtt_ms = avg
                    hs.rtt_sum += avg
                    hs.rtt_cnt += 1
                    hs.rtt_min = avg if hs.rtt_cnt == 1 else min(hs.rtt_min, avg)
                    hs.rtt_max = avg if hs.rtt_cnt == 1 else max(hs.rtt_max, avg)
                    hs.push_rtt(avg)

                ok = 1 if update["recv"] else 0
                hs.push_window(ok)

                if ok:
                    hs.dot_len += 1
                    if hs.dot_len >= cfg.bar_width:
                        hs.dot_len = 0
                else:
                    hs.dot_len = 0

                if update["err"]:
                    hs.last_error = update["err"]

                # CSV output
                if csv_logger:
                    csv_logger.write(
                        f"{update['timestamp']},{host},{hs.sent},{hs.recv},"
                        f"{hs.loss_pct():.1f},{hs.jitter_ms:.1f},"
                        f"{hs.last_rtt_ms or 0:.1f},{hs.avg_rtt():.1f},"
                        f"{hs.rtt_min:.1f},{hs.rtt_max:.1f}"
                    )

            # ---- UI Drawing ----
            rows, real_cols = stdscr.getmaxyx()
            target_cols = cfg.force_cols if cfg.force_cols else real_cols

            stdscr.erase()

            max_bar_possible = max(MIN_BAR, target_cols - NUMERIC_WIDTH - MIN_HOST)
            bar_width = min(cfg.bar_width, max_bar_possible)
            bar_width = max(MIN_BAR, bar_width)
            cfg.bar_width = bar_width

            host_width = max(MIN_HOST, min(MAX_HOST, target_cols - NUMERIC_WIDTH - bar_width))

            # header with version + copyright
            stdscr.attron(curses.A_BOLD)
            stdscr.addstr(0, 0, fit(
                "mping-multi — Multi Host Monitor — Version 1.0 — © Matt Perkins",
                target_cols
            ))
            stdscr.attroff(curses.A_BOLD)

            stdscr.addstr(1, 0, fit("(s=style +/-=bar r=reset q=quit)", target_cols))
            stdscr.hline(2, 0, curses.ACS_HLINE, real_cols)

            info = (
                f"Interval:{cfg.interval_ms}ms  Timeout:{cfg.timeout_s}s  "
                f"Window:{cfg.window}  Bar:{cfg.bar_width}  Style:{cfg.style}  "
                f"Slow≥{cfg.slow_ms}ms  BlocksMax:{cfg.max_lat_ms}ms  "
                f"Mode:{cfg.blocks_mode}({cfg.blocks_avg})  "
                f"{'macOS' if IS_MAC else 'Linux'}"
            )
            stdscr.addstr(3, 0, fit(info, target_cols))
            stdscr.hline(4, 0, curses.ACS_HLINE, real_cols)

            # jitter column included
            hdr = (
                f"{fit('Host', host_width):{host_width}} "
                f"{'Sent':>7} {'Recv':>7} {'Loss%':>7} {'Jitt':>7} "
                f"{'Last':>7} {'Avg':>7} {'Min':>7} {'Max':>7}  Bar"
            )
            stdscr.attron(curses.A_BOLD)
            stdscr.addstr(5, 0, fit(hdr, target_cols))
            stdscr.attroff(curses.A_BOLD)

            y = 6
            for host in hosts:
                if y >= rows - 1:
                    break

                hs = stats[host]
                loss = hs.loss_pct()
                avg_all = hs.avg_rtt()

                if cfg.style == "dots":
                    bar = draw_bar_dots_progress(hs.dot_len, cfg.bar_width)
                else:
                    r = hs.ring_avg() if cfg.blocks_mode == "avg" else hs.last_rtt_ms
                    r = r or avg_all
                    bar = draw_bar_blocks_latency(r, cfg.bar_width, cfg.max_lat_ms)

                c = colour_for_mping_style(loss, avg_all, cfg.slow_ms)
                stdscr.attron(curses.color_pair(c))

                host_disp = f"{fit(host,host_width):{host_width}}"
                last = hs.last_rtt_ms or 0.0

                row = (
                    f"{host_disp} {hs.sent:7d} {hs.recv:7d} {loss:7.1f} {hs.jitter_ms:7.1f} "
                    f"{last:7.1f} {avg_all:7.1f} {hs.rtt_min:7.1f} {hs.rtt_max:7.1f}  {bar}"
                )
                stdscr.addstr(y, 0, fit(row, target_cols))
                stdscr.attroff(curses.color_pair(c))

                if hs.last_error and y + 1 < rows - 1:
                    stdscr.attron(curses.color_pair(4))
                    stdscr.addstr(y + 1, 4, fit("last error: " + hs.last_error, target_cols - 4))
                    stdscr.attroff(curses.color_pair(4))
                    y += 1

                y += 1

            stdscr.addstr(rows - 1, 0,
                          fit("q=quit  s=style  +=wider  -=narrow  r=reset", target_cols))
            stdscr.refresh()

            try:
                ch = stdscr.getch()
            except curses.error:
                ch = -1

            if ch in (ord("q"), ord("Q")):
                break
            elif ch in (ord("s"), ord("S")):
                cfg.style = "blocks" if cfg.style == "dots" else "dots"
            elif ch == ord("+"):
                cfg.bar_width += 2
            elif ch == ord("-"):
                cfg.bar_width = max(MIN_BAR, cfg.bar_width - 2)

            time.sleep(0.05)

    finally:
        if csv_logger:
            csv_logger.close()

        for w in workers:
            w.stop()
        for w in workers:
            w.join()


# ---------------- Arg parse ----------------------
def parse_args(argv):
    p = argparse.ArgumentParser(
        description="mping-multi — multi-host ping with Unicode graphs (curses)"
    )
    p.add_argument("-i","--interval-ms", type=int, default=DEFAULT_INTERVAL_MS)
    p.add_argument("-t","--timeout", type=int, default=DEFAULT_TIMEOUT_S)
    p.add_argument("-w","--window", type=int, default=DEFAULT_WINDOW)
    p.add_argument("--dots", action="store_true")
    p.add_argument("--blocks", action="store_true")
    p.add_argument("--slow-ms", type=int, default=DEFAULT_SLOW_MS)
    p.add_argument("--max-lat-ms", type=int, default=DEFAULT_MAX_LAT_MS)
    p.add_argument("--blocks-mode", choices=["avg","last"], default=DEFAULT_BLOCKS_MODE)
    p.add_argument("--blocks-avg", type=int, default=DEFAULT_BLOCKS_AVG)
    p.add_argument("--cols", type=int)
    p.add_argument("--tty80", action="store_true")

    p.add_argument("--csv-out", type=str,
                   help="write CSV output to this file in parallel")

    p.add_argument("hosts", nargs="+")
    a = p.parse_args(argv)

    cfg = UIConfig()
    cfg.interval_ms = max(100, a.interval_ms)
    cfg.timeout_s   = max(1, a.timeout)
    cfg.window      = max(5, a.window)

    cfg.style = "dots" if a.dots else "blocks"
    cfg.slow_ms     = max(1, a.slow_ms)
    cfg.max_lat_ms  = max(10, a.max_lat_ms)
    cfg.blocks_mode = a.blocks_mode
    cfg.blocks_avg  = max(1, a.blocks_avg)

    cfg.force_cols = 80 if a.tty80 else (a.cols if a.cols and a.cols > 0 else None)

    return cfg, a.hosts, a.csv_out


# ---------------- Entry --------------------------
def main():
    signal.signal(signal.SIGINT, signal.SIG_IGN)

    cfg, hosts, csv_file = parse_args(sys.argv[1:])
    csv_logger = CSVLogger(csv_file) if csv_file else None

    curses.wrapper(curses_main, hosts, cfg, csv_logger)


if __name__ == "__main__":
    main()
